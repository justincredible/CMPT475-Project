/*
Yi (Andy) Li			301146455
Robert Mackenzie		200128755
Justin Symonds			301031838
Si Yuan (Oscar) Zhang	301127012
*/

CoreASM DMTD

use BasicASM
use Standard
use Math

/* Vocabulary */
enum TOKEN = { glassToken, crackedToken }

function break : SET * SET -> BOOL
function token : SET * SET -> TOKEN
function nextMachine : SET -> SET
function reported : SET -> BOOL
/* monitored functions */
function Active : SET * SET -> BOOL
function SentMessage : SET * SET -> BOOL

function crackedTokenEvent : SET * SET -> BOOL
function glassTokenEvent : SET * SET -> BOOL

universe Agents = { tester, environment }

init InitRule

rule InitRule = 
	seqblock
	nodes := toNumber(input("How many machines are in the system?"))
	processes := toNumber(input("How many concurrent processes are running?"))
	inactive := toNumber(input("What is the probability [0,1) a machine will become inactive for any process?"))
	sends := toNumber(input("What is the probability [0,1) a machine sends a message for any process?"))
	index := 0
	
	PROCESS := {}
	MACHINE := {}
	
	while (index < processes)
		seqblock
		add "process_"+(index+1) to PROCESS
		index := index + 1
		endseqblock
	index := 0
	
	par forall p in PROCESS do
		reported(p) := false
	endpar

	if nodes = undef then
		print "Error."
	else
		seqblock
		add "machine_"+index to MACHINE
		par forall m in MACHINE with m = "machine_"+index do
			par
			Agents(m) := true
			program(m) := @SupervisorMachineProgram
			par forall p in PROCESS do
				par
				token(m,p) := crackedToken
				break(m,p) := false
				endpar
			endpar
			mach := m
			original := m
			endpar
		endpar
		index := index + 1
			
		while (index < nodes)
			seqblock
			add "machine_"+index to MACHINE
			par forall m in MACHINE with m = "machine_"+index do
				par
				Agents(m) := true
				program(m) := @RegularMachineProgram
				par forall p in PROCESS do
					break(m,p) := false
				endpar
				nextMachine(mach) := m
				mach := m
				endpar
			endpar
			if index = (nodes - 1) then
				nextMachine(mach) := original
			index := index + 1
			endseqblock
		endseqblock
	
	program(environment) := @EnvironmentProgram
	program(self) := undef
	endseqblock

rule ReactOnEvents(m,p) = 
	par
	if crackedTokenEvent(m,p) then
		par
		token(m,p) := crackedToken
		crackedTokenEvent(m,p) := false
		endpar
	if glassTokenEvent(m,p) then
		par
		token(m,p) := glassToken
		glassTokenEvent(m,p) := false
		endpar
	if SentMessage(m,p) then
		par
		break(m,p) := true
		SentMessage(m,p) := false
		endpar
	endpar

rule InitializeMachine(m,p) =
	par
	token(m,p) := undef
	break(m,p) := false
	endpar

rule RegularMachineProgram =
par
	par forall p in PROCESS do
		par
		ReactOnEvents(self,p)
		if not( Active(self,p) ) and ( token(self,p) != undef ) then
			par
			InitializeMachine(self,p)
			if break(self,p) then
				crackedTokenEvent(nextMachine(self),p) := true
			else
				glassTokenEvent(nextMachine(self),p) := true
			endpar
		endpar
	endpar
endpar

rule SupervisorMachineProgram =
par
	par forall p in PROCESS do
		par
		ReactOnEvents(self,p)
		if not( Active(self,p) ) and ( token(self,p) != undef ) then
			if not( break(self,p) ) and ( token(self,p) = glassToken ) then
				ReportGlobalTermination(p)
			else
				par
				InitializeMachine(self,p)
				glassTokenEvent(nextMachine(self),p) := true
				endpar
		endpar
	endpar
endpar

rule ReportGlobalTermination(p) =
	par
	if not reported(p) then
		par
		print p+" terminated"
		reported(p) := true
		endpar
	endpar

rule EnvironmentProgram =
par
	par forall m in MACHINE with program(m) = @RegularMachineProgram do
		par
		choose p in PROCESS do
			if random < inactive then
				Active(m,p) := false
		choose p in PROCESS do
			if random < sends then
				SentMessage(m,p) := true
		endpar
	endpar
	par forall s in MACHINE with program(s) = @SupervisorMachineProgram do
		par 
		choose p in PROCESS do
			if random < inactive then
				Active(s,p) := false
		choose p in PROCESS do
			if random < sends and not reported(q) then
				SentMessage(s,p) := true
		endpar
	endpar
endpar