/*
Yi (Andy) Li			301146455
Robert Mackenzie		200128755
Justin Symonds			301031838
Si Yuan (Oscar) Zhang	301127012
*/

CoreASM DMTD

use BasicASM
use Standard
use Math

/* Vocabulary */
enum TOKEN = { glassToken, crackedToken }
enum PROCESS = { process_1, process_2, process_3 }

function break : Agents * PROCESS -> BOOL
function token : Agents * PROCESS -> TOKEN
function nextMachine : Agents -> Agents
function reported : PROCESS -> BOOL
function machineRank : Agents -> NUMBER
/* monitored functions */
// When a machine is active whenver it has work to do for a given process
function Active : Agents * PROCESS -> BOOL
function SentMessage : Agents * PROCESS -> BOOL
function crackedTokenEvent : Agents * PROCESS -> BOOL
function glassTokenEvent : Agents * PROCESS -> BOOL

universe Agents = { tester, environment, machine_0, machine_1, machine_2, machine_3, machine_4 }

init InitRule

rule InitRule = 
	seqblock
	/*nodes := toNumber(input("How many machines are in the system?"))
	processes := toNumber(input("How many concurrent processes are running?"))*/
	inactive := toNumber(input("What is the probability [0,1) a machine will become inactive for any process?"))
	sends := toNumber(input("What is the probability [0,1) a machine sends a message for any process?"))
	starts := toNumber(input("What is the probability [0,1) a machine already has work to do for any process?"))
	index := 0
	null := {}
	
	choose m in Agents with toString(m) = "machine_"+index do
		{
		program(m) := @SupervisorMachineProgram
		machineRank(m) := index
		forall p in PROCESS do
			token(m,p) := crackedToken
		mach := m
		original := m
		}
	index := index + 1
	
	// the 3 agents are Init, tester, and environment
	while (index < size(Agents) - 3)
		seqblock
		choose m in Agents with toString(m) = "machine_"+index do
			{
			program(m) := @RegularMachineProgram
			machineRank(m) := index
			nextMachine(mach) := m
			mach := m
			}
		if index = size(Agents) - 4 then
			nextMachine(mach) := original
		index := index + 1
		endseqblock

	forall p in PROCESS do
		{
		forall m in Agents with machineRank(m) != undef do
			if random < starts then
				Active(m,p) := true
			else
				Active(m,p) := false
		reported(p) := false
		}

	program(environment) := @EnvironmentProgram
	program(self) := undef
	endseqblock

rule ReactOnEvents(m,p) = 
	seqblock
	{
	if crackedTokenEvent(m,p) then
		token(m,p) := crackedToken
	if glassTokenEvent(m,p) then
		token(m,p) := glassToken
	if SentMessage(m,p) then
		break(m,p) := true
	}
	{
		crackedTokenEvent(m,p) := false
		glassTokenEvent(m,p) := false
		SentMessage(m,p) := false
	}
	endseqblock

rule InitializeMachine(m,p) =
	{
	token(m,p) := undef
	break(m,p) := false
	}

rule ForwardToken(t,m,p) =
	{
	print "The "+t+" of "+p+" was passed to "+toString(m)+"."
	if t = glassToken then
		glassTokenEvent(m,p) := true
	if t = crackedToken then
		crackedTokenEvent(m,p) := true
	}

rule ReportGlobalTermination(p) =
	if not reported(p) then
		{
		print p+" terminated"
		reported(p) := true
		}

rule RegularMachineProgram =
	choose p in PROCESS with reported(p) = false do
		{
		ReactOnEvents(self,p)
		if not Active(self,p) and token(self,p) != undef then
			{
			InitializeMachine(self,p)
			if break(self,p) then
				ForwardToken(crackedToken,nextMachine(self),p)
			else
				ForwardToken(token(self,p),nextMachine(self),p)
			}
		}

rule SupervisorMachineProgram =
	choose p in PROCESS with reported(p) = false do
		{
		ReactOnEvents(self,p)
		if not Active(self,p) and token(self,p) != undef then
			{
			if not break(self,p) and token(self,p) = glassToken then
				ReportGlobalTermination(p)
			else
				{
				InitializeMachine(self,p)
				ForwardToken(glassToken,nextMachine(self),p)
				}
			}
		}

/*
 * Assumptions:
 *	- a machine can only work on one process at any instant
 * 	- a machine can only send work messages forward in the chain
 *	- a machine will send work for a given process to another machine only when the receiving machine is not already have work
 *
 */
rule EnvironmentProgram =
	forall m in Agents with machineRank(m) != undef do
		choose p in PROCESS with Active(m,p) = true do
			seqblock
			if random < inactive then
				Active(m,p) := false
			if random < sends then
				// choose s in Agents results in: Value of choose condition is not Boolean.
				choose s in {nextMachine(m),nextMachine(nextMachine(m))} with Active(s,p) = false and toNumber(machineRank(s)) > toNumber(machineRank(m)) do
					{
					SentMessage(m,p) := true
					Active(s,p) := true
					}
			endseqblock